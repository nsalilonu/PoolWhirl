<!DOCTYPE html>
<html>

<head>
  <!-- the next three lines try to discourage browser from keeping page in cache -->
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="-1">
  <meta http-equiv="cache-control" content="no-store">

  <title> COS426 Final Project &mdash; Pool Whirl</title>
</head>
<script src="teddyMesh.js" type="module"></script>
<script src="rubberDuckMesh.js" type="module"></script>

<body style="background-color: rgb(226, 113, 147);">
  <h1 id="h1" , style="color: white;">Pool Whirl</h1>
  <p style="color:rgb(248, 248, 248)">By: Sean-Wyn Ng, Nsomma Alilonu, Rachel Lee, and Emily Yin</p>
  <p style="color:rgb(5, 146, 99)">Save your teddy bear from an untimely demise!</p>
  <script src="three.min.js"></script>
  <script src="OrbitControls.js"></script>



  <canvas id="canvas"></canvas>

  <script type="module">
    import { teddyMesh, teddyMunch, teddyInit, bounce, handleCollisions } from "./teddyMesh.js";
    import { duckMesh } from "./rubberDuckMesh.js";

    // Camera controls:
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas });
    renderer.setSize(window.innerWidth, window.innerHeight);
    var camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 1, 10000);

    /*camera.rotateX(Math.PI * 1.5);
    camera.translateY(100);
    camera.translateX(500);
    camera.translateZ(300);*/

    /*camera.position.y = 200; 
      camera.position.z =  50; 
      camera.rotation.x = Math.PI / 4;*/
    // Orbit Controls:

    const controls = new THREE.OrbitControls(camera, canvas);
    controls.target.set(0, 10, 175);
    controls.update();

    const scene = new THREE.Scene();

    // Background scene:
    var sceneColor = new THREE.Color(0xff6666);
    scene.background = sceneColor;

    // Cone:
    let coneGeometry = new THREE.ConeGeometry(10, 4, 10, 10, true);
    coneGeometry.elementsNeedUpdate = true;
    let coneMaterial = new THREE.MeshPhongMaterial({ color: 0x00ccff });
    coneMaterial.side = THREE.DoubleSide;
    coneGeometry.scale(50.0, 50.0, 50.0);
    let cone = new THREE.Mesh(coneGeometry, coneMaterial);
    cone.castShadow = true;
    cone.dynamic = true;
    scene.add(cone);
    cone.rotation.x = - Math.PI * 1.25;

    let vertices = coneGeometry.vertices;
    let length = particleNum;
    let totParticles = coneGeometry.vertices.length - 1;
    let randomRanges = [];
    let scale = 20;
    let timeScale = 100;
    // selecting random particles
    for (let i = 0; i < length; i++) {
      let randomVertex = Math.round(Math.random() * totParticles);
      let randomTime = Math.random() * timeScale; 
      let randomScale = Math.round(Math.random() * scale) + 20; // Random number between 20 and 40.
      // added direction to keep track
      // keep track of original position
      randomRanges.push({vertex: randomVertex, time: randomTime, scale: randomScale});
    }

// for each time step, increment vertex only if it is in a certain modulo group (just use index within array)
// direction can also be determined maybe?
function moveVertices(timer, randomRanges) {
    let length = randomRanges.length;
    let vertices = coneGeometry.vertices;
    for (let i = 0; i < length; i ++) {
        let scale = (Math.sin(randomRanges[i].time)) * 0.5; // The increment you move the vertex each time
        let currentVertex = randomRanges[i].vertex; // A random vertex in the list.
        let specialTime = Math.sin(timer * randomRanges[i].scale); // Defines when to change the direction. Different for every vertex.
        if (specialTime > 0) { // Indicates to change the direction of motion.
        vertices[currentVertex].setY(vertices[currentVertex].y + scale);
        }
        else {
        vertices[currentVertex].setY(vertices[currentVertex].y + (-scale));
        }
    }
}

let yAxis = new THREE.Vector3(0, 1, 0);
teddyMesh.rotateOnAxis(yAxis, Math.PI);

teddyMesh.translateZ(175);
teddyMesh.translateY(10);
teddyMesh.rotateX(Math.PI);
teddyMesh.rotateY(Math.PI / 2);

cone.add(teddyMesh);
let teddyPosition = teddyMesh.localToWorld(teddyMesh.position.clone());
camera.position.set(teddyPosition.x, teddyPosition.y, teddyPosition.z);
camera.translateZ(300);
camera.translateY(130);
camera.translateX(10);

// camera.lookAt(teddyPosition);

// Lighting:
const color = 0xFFFFFF;
const sunColor = 0xffa51b;
const light = new THREE.DirectionalLight(color, 1);
light.position.set(camera.position.x, camera.position.y, camera.position.z-20);
const sunLight = new THREE.DirectionalLight(sunColor, 0, 1, 0);
sunLight.position.set(0, 0, 0);
const ambient = new THREE.AmbientLight(0x404040, 1);
scene.add(light);
scene.add(sunLight);
scene.add(ambient);

var axesHelper = new THREE.AxesHelper( 100 );
scene.add( axesHelper );

// Animation:
var time = 0;
let randomRanges = getRandomRanges(300);
let count = 0;
let timer;
let timer2;
let timer3;
let timer4;
animate();

function animate(){
  time += 30;
  requestAnimationFrame(animate);
  render();
}

function render() {
  timer = time * 0.0002 * 0.8;
  // get teddy's position before
  let teddyOldPosition = teddyMesh.localToWorld(teddyMesh.position.clone());
  let cameraOldPosition = camera.localToWorld(camera.position.clone());
  //cone.rotation.y = timer * 10;
    let v = Math.round((count / 3) % 3);

    // only use randomranges like once
    // a condition like this, can change later
    //if (v == 0){
      //timer2 = time * 0.0002 * 0.8;
      moveVertices(timer, randomRanges);
    //}

    // //else if (v == 1) {
    //   //timer = -0.4 + time * 0.0002 * 0.8;
    //   moveVertices(timer, randomRanges, v);
    // //} 

    // //else if (v == 2) {
    //   //timer = 0.2 + time * 0.0002 * 0.8;
    //   moveVertices(timer, randomRanges, v);
    //} 

    count++;
        
    cone.geometry.computeFaceNormals();
    cone.geometry.computeVertexNormals();
    cone.geometry.normalsNeedUpdate = true;
    cone.geometry.verticesNeedUpdate = true;


    handleCollisions(cone.geometry.vertices);
    teddyMunch();
    bounce(timer);
    
  

   // Render! (by golly I hope this works!)
  renderer.render(scene, camera);

  teddyPosition = teddyMesh.localToWorld(teddyMesh.position.clone());
  // new - old
  let changeTeddy = teddyPosition.clone().sub(teddyOldPosition.clone());
  // camera's old position plus the change in teddy's position
  //camera.position.set(cameraOldPosition.x + changeTeddy.x, cameraOldPosition.y + changeTeddy.y, cameraOldPosition.z + changeTeddy.z);
  camera.lookAt(teddyPosition);
  }
</script>

</body>

</html>